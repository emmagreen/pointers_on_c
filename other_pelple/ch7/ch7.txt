1.通过两种方式向编译器提供关于函数的信息：
  1）在同一个源文件的开始出现函数定义。
  2）在文件的开始提供函数原型，函数的参数的名字不是必须的。
2.将函数原型放在一个文件中，这样函数原型具有文件作用域，消除了多份原型拷贝的不一致性。
3.一个没有参数的函数原型应该写成如下的形式： int *func( void ) 其中void应该表示没有参数。
4.如果编译器无法看到一个函数的任何声明，那么编译器假定函数返回一个整型值，对于那些返回值不是
整型的函数，在调用之前对他们进行声明是很重要的，可以避开由于不可预测的类型转换导致的错误；并
且对于没有函数原型的函数，传递给函数的实参要进行缺省参数提升，char和short类型的实参转换成为
int类型，float类型的实参被转换成double类型。
5.函数的参数是通过传值方式进行传递，实际是传递实参的一份拷贝。
6.递归的两个条件：
  1）存在限制条件，当符合这个条件时在不执行递归
  2）每次递归之后越来越来接近这个限制条件
7.黑盒技术
8.如果递归函数的内部执行的最后一条语句是调用自身的时候（称为尾部递归），可以很容易的改写成循环（
迭代）的形式，通常效率更高。
9.在可变参数列表中，普通参数必须以某种方式向函数传递实际参数的数量，当参数列表中可变部分的参数传
递给函数时，要经历缺省参数提升。
10.当使用数组作为函数参数的时候，数组并没有办法判断数组的长度，所以可以在参数中显示的传递数组的
参数。
